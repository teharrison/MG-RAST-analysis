<html><head><title>KBase_matR_tutorial.8-7-12</title><style type="text/css">ol{margin:0;padding:0}.c12{max-width:468pt;background-color:#ffffff;padding:72pt 72pt 72pt 72pt}.c9{font-size:24pt;font-weight:bold}.c7{text-indent:36pt;margin-left:108pt}.c1{height:11pt;direction:ltr}.c8{text-indent:36pt;margin-left:36pt}.c0{font-style:italic}.c4{direction:ltr}.c10{font-weight:bold}.c3{text-align:center}.c6{color:#0000ff}.c11{text-indent:36pt}.c13{color:#ff0000}.c2{color:#9900ff}.c5{color:#00ff00}.title{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:36pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:"Georgia";padding-bottom:4pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:18pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#666666;font-size:12pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Arial";padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#666666;font-size:10pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:10pt;font-family:"Arial";padding-bottom:2pt}</style></head><body class="c12"><p class="c4"><span class="c9">Notes are in black --</span></p><p class="c4"><span class="c2 c9">code to cut and paste into R is in purple</span></p><p class="c4"><span class="c9 c5">Notes to be ignored</span></p><p class="c4"><span>When there are multiple lines of code, you can cut and paste all of them at once - if code is separated with a blank line - cut/paste the blank line separated one at a time - for example</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">cut/paste_these_together </span></p><p class="c4"><span class="c2">cut/paste_these_together</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">cut/paste_these_sperately</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c2">cut/paste_these_sperately</span></p><p class="c1"><span></span></p><p class="c4"><span>NOTE:</span></p><p class="c4"><span>this has to be run first to change the default server:</span></p><p class="c4"><span class="c2">mconfig$server(&quot;http://test.metagenomics.anl.gov/api.cgi/&quot;)</span></p><p class="c4"><span class="c6">[do this AFTER:</span></p><p class="c4"><span class="c6">&gt; library (matR) </span></p><p class="c4"><span class="c6">--dtb]</span></p><p class="c4"><span>##################################</span></p><p class="c4"><span>Begin Tutorial &gt;</span></p><p class="c1"><span></span></p><p class="c4"><span>We&#39;ll work through a typical data analysis</span></p><p class="c4"><span>We&#39;ll be using annotation abundance data generated via MG-RAST for a series</span></p><p class="c4"><span>of different animal guts</span></p><p class="c1"><span></span></p><p class="c4"><span>We start by looking through public data available to KBase -- in this case, metagenomic sequence and annotation</span></p><p class="c4"><span>data available as public data in MG-RAST</span></p><p class="c1"><span></span></p><p class="c4"><span>Specifically, we&#39;ll use the client to download annotation abundance profiles for a number of samples through MG-RAST,</span></p><p class="c4"><span>we&#39;ll perform some preliminary analyses to determine if samples can be used in a comparative analysis, and then we&#39;ll work through</span></p><p class="c4"><span>a typical analysis.</span></p><p class="c1"><span></span></p><p class="c4"><span>We start with a collection of 14 samples that represent 4 distinct biomes, the guts of chicken, mouse, cow, and fish</span></p><p class="c1"><span></span></p><p class="c4"><span>First, we&#39;ll download a single data set, and see how we can use matR to explore it.</span></p><p class="c4"><span>The data are in the form of functional annotation based abundance profiles for a series of gut samples:</span></p><p class="c4"><span>4 samples from Chicken cecum &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;chic&rdquo;</span></p><p class="c4"><span>3 from cow rumen &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;cow&rdquo;</span></p><p class="c4"><span>2 from mouse gut &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;mus&rdquo;</span></p><p class="c4"><span>2 from fish gut &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;fish&rdquo;</span></p><p class="c1"><span></span></p><p class="c4"><span>We create a list that has the sample name and mgrast id for each of our samples:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">gut_samples &lt;- c (chic.1= &quot;4440283.3&quot;,</span></p><p class="c4"><span class="c2">chic.2 = &quot;4440284.3&quot;,</span></p><p class="c4"><span class="c2">chic.3 = &quot;4440285.3&quot;,</span></p><p class="c4"><span class="c2">chic.4 = &quot;4440286.3&quot;,</span></p><p class="c4"><span class="c2">cow.1 = &quot;4441679.3&quot;,</span></p><p class="c4"><span class="c2">cow.2 = &quot;4441680.3&quot;,</span></p><p class="c4"><span class="c2">cow.3 = &quot;4441682.3&quot;,</span></p><p class="c4"><span class="c2">mus.1 = &quot;4440463.3&quot;,</span></p><p class="c4"><span class="c2">mus.2 = &quot;4440464.3&quot;,</span></p><p class="c4"><span class="c2">fish.1 = &quot;4441695.3&quot;,</span></p><p class="c4"><span class="c2">fish.2 = &quot;4441696.3&quot;</span></p><p class="c4"><span class="c2">)</span></p><p class="c1"><span></span></p><p class="c4"><span>Now we download the data for these samples into an R object called my_gut_data</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_gut_data &lt;- collection(gut_samples) </span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>It could take a couple minutes for the data to load</span></p><p class="c4"><span>By default, you will download the following data for each of the samples</span></p><p class="c4"><span>- raw abundance counts</span></p><p class="c4"><span class="c2">my_gut_data$count</span></p><p class="c4"><span>- abundance counts that have been normalized and standardized per sample</span></p><p class="c4"><span class="c2">my_gut_data$normed</span></p><p class="c4"><span>- average e value for each annotation</span></p><p class="c4"><span class="c2">my_gut_data$evalue </span><span class="c6">[something is messed up with this call. &nbsp;the data is fubar&rsquo;d]</span></p><p class="c4"><span>- average read lengths for each annotation</span></p><p class="c4"><span class="c2">my_gut_data$length</span></p><p class="c4"><span>- average percent identity for similarities calculated for each annotations</span></p><p class="c4"><span class="c2">my_gut_data$percentid</span></p><p class="c4"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c4"><span>We can look at the metadata for each metagenome</span></p><p class="c4"><span>First we extract all of the metadata for the group of samples in our collection</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_metadata &lt;- metadata(my_gut_data)</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>Then we can look at the &ldquo;names&rdquo; property to see the mgrast id&rsquo;s for each of the samples </span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c2">names(my_metadata)</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>We take the first id, and pull out the metadata that corresponds to just that sample</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c2">single_sample_metadata &lt;- my_metadata[[&quot;4440283.3&quot;]]</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>We can look at all of the metadata for the sample</span></p><p class="c1"><span class="c10 c2"></span></p><p class="c4"><span class="c2">single_sample_metadata</span></p><p class="c1"><span class="c10 c2"></span></p><p class="c4"><span>Or drill down to look at individual metadata values - examples below pull out individual metadata values:</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c6">[for copying &amp; pasting it&rsquo;s handy to have purple text on separate lines from non-command text]</span></p><p class="c4"><span class="c2">single_sample_metadata$name &nbsp;</span><span>user given name</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c2">single_sample_metadata$metadata$library$data$seq_center </span><span>sequencing center</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c2">single_sample_metadata$metadata$library$data$seq_meth </span><span>sequencing method/technology</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">single_sample_metadata$metadata$sample$data$biome</span><span class="c2">&nbsp;</span><span>biome</span></p><p class="c1"><span></span></p><p class="c4"><span>Let&rsquo;s say we want to look at the same metadata value for all of the samples, we can do this:</span></p><p class="c1"><span></span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c2">for (i in 1:dim(as.matrix(names(my_metadata)))[1]){ &nbsp;</span></p><p class="c4 c11"><span class="c2">print( </span></p><p class="c4 c8"><span class="c2">paste( names(my_metadata)[i], &quot; &nbsp; &quot;,</span></p><p class="c4 c7"><span class="c2">(</span></p><p class="c4 c11"><span class="c2">my_metadata[[names(my_metadata)[i]]]$metadata$library$data$metagenome_name</span></p><p class="c7 c4"><span class="c2">)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)</span></p><p class="c4"><span class="c2">}</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>Here we see the mgrastid and the user given sample name </span></p><p class="c4"><span>use this as the middle line and you can see the biome</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_metadata[[names(my_metadata)[i]]]$metadata$sample$data$biome</span></p><p class="c1"><span></span></p><p class="c4"><span>This to see the sequencing technology</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_metadata[[names(my_metadata)[i]]]$metadata$library$data$seq_meth</span></p><p class="c1"><span></span></p><p class="c4"><span>This is a little clunky now, but in the very near future this will allow us to easily sort and group samples by their metadata. </span></p><p class="c1"><span></span></p><p class="c4"><span>Before we perform comparative analyses, we want to take a look at the data distributions. &nbsp;In this case, the distributions of the raw abundance counts for each of the samples:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">render (my_gut_data, views = &quot;count&quot;)</span></p><p class="c4"><span class="c6">[use parameter main = &ldquo;alternate title&rdquo; if you want]</span></p><p class="c1"><span></span></p><p class="c4"><span>Here we can clearly see bias in the distributions of the raw counts -- we can eliminate the majority of this bias if we normalized and standardize the abundance data from each sample.</span></p><p class="c4"><span>Now we look at the distribution of the raw (top) and normalized (bottom) counts: </span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">render (my_gut_data, views = c (&quot;count&quot;, &quot;normed&quot;))</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>Normalization/standardization of the abundance profiles has made them more comparable</span></p><p class="c1"><span></span></p><p class="c4"><span>We can perform a preliminary comparative analysis with a PCoA based analysis of the data:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_PCoA &lt;- mpco (my_gut_data$normed, method = &quot;euclidean&quot;)</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>We can look at the raw output of the analysis like this:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_PCoA</span></p><p class="c1"><span></span></p><p class="c4"><span>or, we can produce a visualization of the results like this:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">render (my_PCoA, main = &quot;PCoA of gut data&quot;, labels = names(gut_samples))</span></p><p class="c1"><span></span></p><p class="c4"><span>Interesting; it&rsquo;s pretty clear that the abundance profiles cluster by host. &nbsp;We can make this a little clearer if we color the data by organism. &nbsp;First, we create a list that we can use to color the sample in the PCoA, and to establish groupings for subsequent statistical tests: </span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_color_groupings &lt;- c ( rep(&quot;red&quot;, 4), rep(&quot;blue&quot;, 3), rep(&quot;green&quot;, 2), rep(&quot;hotpink&quot;,2))</span></p><p class="c1"><span></span></p><p class="c4"><span>Now we can create a PCoA with each of the groups colored:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">render (my_PCoA, main = &quot;Colored PCoA of gut data&quot;, col = my_color_groupings, labels = names(gut_samples))</span></p><p class="c1"><span></span></p><p class="c4"><span>Another way to visualize these data is with a heatmap dendrogram, like this:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">mheatmap (my_gut_data$normed, image_out = &quot;my_gut_data.heatmap_dendrogram.jpg&quot;, labRow = NA, labCol = names(gut_samples), col_lab_mult = 1.2, margins = c (9,1), image_title = &quot;my_gut_data.heatmap_dendrogram&quot;)</span></p><p class="c4"><span>&nbsp;</span></p><p class="c4"><span>This may take a minute or two - when it&rsquo;s finished, we can open it from R like this:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">system(&quot;open my_gut_data.heatmap_dendrogram.jpg&quot;)</span></p><p class="c1"><span></span></p><p class="c4"><span>Each line represents the abundance of a single subsystem (red = low to green = high).</span></p><p class="c4"><span>Once again, we clearly see that functional content of gut microbes varies as a function of host -- but we could have guessed that before sequencing. &nbsp;What we really want to get at is more specific information: what functions are responsible for the differences among the hosts --- in other words, which subsystems exhibit statistically significant differences in abundance among the 4 types of host (chicken, cow, mouse, and fish). &nbsp;We can use the groupings from before to perform a statistical test -- remember the boxplots? -- they indicate that the data are normally (well almost) distributed, justifying the use of a parametric test, in this case, ANOVA:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_gut_ANOVA_stats &lt;- doStats(my_gut_data$normed, my_color_groupings, &quot;ANOVA-one-way&quot;)</span></p><p class="c1"><span></span></p><p class="c4"><span>We can look at the raw results this way:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_gut_ANOVA_stats</span></p><p class="c1"><span></span></p><p class="c4"><span>That&rsquo;s not too much use -- what we want to do is use the statistical output to subselect the data. i.e. use the results of the statistical analysis to select the subsystems/functions that exhibit the most significant differences among the 4 examined hosts. First we pull the p values out of the statistical analysis results:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_p_values &lt;- my_gut_ANOVA_stats[ ,6]</span></p><p class="c1"><span></span></p><p class="c4"><span>Now we subselect based on relatively stringent criteria to help control for the FDR - we&rsquo;ll use a p value of 0.05 as the threshold, but then apply the Bonfferoni adjustment ( 0.05/num_tests = 0.05/1040 = 5E-07 ) - first, lets see if any of the data exhibit this level of significance:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">min(my_p_values)</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>dough, this is too stringent. We need to try something else -- here we can use another R package to easily use an alternative means to apply FDR control. &nbsp;We&rsquo;ll use q value analysis.</span></p><p class="c4"><span>Install and load the qvalue package:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">source(&quot;http://bioconductor.org/biocLite.R&quot;)<br>biocLite(&quot;qvalue&quot;)</span></p><p class="c4"><span class="c2">library(qvalue)</span></p><p class="c4"><span class="c6">[an annoying thing that can happen in the middle of this sequence of commands (specifically, after the second) is that you&rsquo;ll be prompted to update packages used by qvalue for which a new version is available]</span></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c6">[also this crashed hard for me just now, I think due to version mismatches between R and various packages, although it ran fine the 2nd time. something to be careful about. &nbsp;R stuff is very finicky about versions.]</span></p><p class="c1"><span></span></p><p class="c4"><span>Perform a conventional q value analysis of the p values -- we&rsquo;ll require a relatively stringent FDR level</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_q_value_analysis &lt;- qvalue(my_p_values, fdr.level = 0.001)</span></p><p class="c1"><span></span></p><p class="c4"><span>Now we can subselect just those subsystems that exhibit an FDR of 0.001 or better:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_FDR_controlled_gut_data &lt;- my_gut_data$normed [names (my_q_value_analysis$significant) [my_q_value_analysis$significant==TRUE], ]</span></p><p class="c1"><span></span></p><p class="c4"><span>and we can generate visualizations and or simple table outputs for the data that pass FDR control:</span></p><p class="c1"><span></span></p><p class="c4"><span>We can generate a PCoA like this:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_FDR_controlled_PCoA &lt;- mpco (matrix(my_FDR_controlled_gut_data@x,ncol=11), method = &quot;euclidean&quot;)</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">render (my_FDR_controlled_PCoA, main = &quot;(FDR &lt;= 0.001) Colored PCoA of gut data&quot;, col = my_color_groupings, labels = names(gut_samples))</span></p><p class="c1"><span></span></p><p class="c4"><span>or a heatmap like this:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">mheatmap (matrix(my_FDR_controlled_gut_data@x,ncol=11), image_out = &quot;my_subselected_gut_data.heatmap_dendrogram.jpg&quot;, labRow = NA, labCol = names(gut_samples), col_lab_mult = 1.2, margins = c (9,1), image_title = &quot;my_subselected_gut_data.heatmap_dendrogram&quot;)</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c2">system(&quot;open my_subselected_gut_data.heatmap_dendrogram.jpg&quot;)</span></p><p class="c1"><span></span></p><p class="c4"><span>Note that for these last two options, we&rsquo;re using a lot more R code -- this will be replaced with more user friendly functions for C and D users, but A and B users will be able to access the R code to customize analyses and their visualizations.</span></p><p class="c1"><span></span></p><p class="c4"><span>If we compare the original PCoA and heatmap-dendrograms to those created from the statistically subselected data, we can see that the differences among the 4 groups of hosts become much more distinct</span></p><p class="c1"><span></span></p><p class="c4"><span>Finally - if we want to write the analysis outputs to files (for Excel, Matlab, etc.) we can do this:</span></p><p class="c1"><span></span></p><p class="c4"><span>First - pick out the data we want to write to file - here we will output the abundance profiles and statistical results for all data considered in our analysis:</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c2">my_output_data &lt;- cbind(as.matrix(my_gut_data$normed), my_gut_ANOVA_stats, matrix(my_q_value_analysis$qvalues, ncol=1), matrix(my_q_value_analysis$significant, ncol=1))</span></p><p class="c4"><span class="c2">dimnames(my_output_data)[[2]][18] &lt;- &quot;qvalue&quot;</span></p><p class="c4"><span class="c2">dimnames(my_output_data)[[2]][19] &lt;- &quot;pass FDR &lt;= 0.001&quot;</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c2">write.table(my_output_data, file = &quot;my_output_analysis.txt&quot;, col.names=NA, row.names = TRUE, sep=&quot;\t&quot;, quote=FALSE)</span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c4"><span class="c9 c13">DONE - Just notes from here on.</span></p><p class="c1"><span></span></p><p class="c4"><span class="c5">my_metadata[[names(my_metadata)[i]]]$metadata$library$data$metagenome_name</span></p><p class="c1"><span></span></p><p class="c4"><span class="c5">my_metadata[[test]]$metadata$sample$data$biome</span></p><p class="c4"><span class="c5">my_metadata[[names(my_metadata)[1]]]$metadata$sample$data$biome</span></p><p class="c1"><span></span></p><p class="c4"><span class="c5">for (i in 1:dim(as.matrix(names(my_metadata)))[1]){print(names(my_metadata)[i])} # print ids</span></p><p class="c4"><span class="c5">my_metadata[[&quot;4440283.3&quot;]]$metadata$library$data$seq_center # value from 1 clctn sample</span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c4"><span class="c0">pvals &lt;- results [ , 4]</span></p><p class="c4"><span class="c0">subselection</span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c0">- raw subselection data</span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c0">- images created from subselection</span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c0">subW &lt;- my_gut_data$normed [names (</span><span>my_q_value_analysis$significant</span><span class="c0">) [</span><span>my_q_value_analysis$significant==TRUE</span><span class="c0">], ]</span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c0">pvals &lt;- results [ , 4]</span></p><p class="c4"><span class="c0">subW &lt;- W$normed [names (pvals) [pvals &lt; 0.0000005], ]</span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c0">### comparing dimensions of the original and subselection matrices shows what</span></p><p class="c4"><span class="c0">### proportion of the original functional annotations are retained:</span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c0">dim (W$normed)</span></p><p class="c4"><span class="c0">dim (subW)</span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c0">### finally, a heatmap of the subselected matrix highlights rows of interest more clearly than before:</span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c0">mheatmap (subW, image_out = &quot;waters_sub_HD.jpg&quot;, labRow = NA, labCol = names (waters), col_lab_mult = 1.2, margins = c (8,1), image_title = &quot;subselection&quot;)</span></p><p class="c4"><span class="c0">system (&quot;open waters_sub_HD.jpg&quot;)</span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c0">### this analysis could continue by setting more restrictive p-value thresholds, like this:</span></p><p class="c1"><span class="c0"></span></p><p class="c4"><span class="c0">subW01 &lt;- W$normed [names (pvals) [pvals &lt; 0.01], ]</span></p><p class="c4"><span class="c0">subW003 &lt;- W$normed [names (pvals) [pvals &lt; 0.003], ]</span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c4"><span>Looks as though fish exhbit the most unique aundance profiles, lets analyze again with just two groups, fish, and everything else:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_color_groupings.2 &lt;- c ( rep(&quot;blue&quot;, 9), rep(&quot;hotpink&quot;,2)) &nbsp; </span><span>...</span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c4"><span>write p value analyses to a tab delimited text you can open in excel</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">write.table(my_stats, file = &quot;my_ANOVA_P_values.txt&quot;, col.names=NA, row.names =TRUE, sep=&quot;\t&quot;, quote=FALSE)</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>or get a little fancier and produce a table that has the normalized abundance values followed by the ANOVA analyses</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_output_data &lt;- cbind(as.matrix(my_data$normed_function_counts),my_stats)</span></p><p class="c4"><span class="c2">write.table(my_output_data, file = &quot;my_normed_abundances_and_ANOVA_P_values.txt&quot;, col.names=NA, row.names = TRUE, sep=&quot;\t&quot;, quote=FALSE)</span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c1 c3"><span></span></p><p class="c1 c3"><span></span></p><p class="c1 c3"><span></span></p><p class="c4"><span class="c6">QUESTIONS FOR DAN:</span></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c6">if I want to get the metadata for a single sample in a collection, what is the syntax?</span></p><p class="c4"><span class="c6">I know metadata(collection) gives me the whole bag</span></p><p class="c4"><span>mm &lt;- metadata (&lt;ids&gt;)</span></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c6">or alternatively, if I want to see just a certain class of metadata for the collections -- say all of the $id in the collection</span></p><p class="c4"><span>to access a given element use mm$&lt;id&gt;$field$subfield$...$subfield</span></p><p class="c4"><span>or:</span></p><p class="c4"><span>j &lt;- c (&ldquo;&lt;id&gt;&rdquo;, &ldquo;field&rdquo;, &ldquo;subfield&rdquo;, &hellip;)</span></p><p class="c4"><span>mm [[ j ]]</span></p><p class="c4"><span>but there is not presently a convenient way to get the same field from every one of multiple ids. &nbsp;(there&rsquo;s a slight problem with the very idea, since different metagenomes are not guaranteed to _have_ any of the same metadata). &nbsp;</span></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c6">for the boxplot functions - what is the syntax to change names from the default (mgrast ids)</span></p><p class="c4"><span>pass a parameter names = c (...) to &ldquo;render&rdquo; </span></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c6">if I want to see all of the counts, what is the syntax -- if I do my_collection$counts &nbsp;I get NULL</span></p><p class="c4"><span>use count not counts</span></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c6">does the current version have q values?</span></p><p class="c4"><span>no</span></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c6">We need to change the stat output to include the group averages</span></p><p class="c4"><span class="c6">We also need to add (probably as first line) the list of sample that are in each group of any statistical analysis</span></p><p class="c4"><span>ok</span></p><p class="c1"><span></span></p><p class="c1 c3"><span></span></p><p class="c1 c3"><span></span></p><p class="c1 c3"><span></span></p><p class="c1 c3"><span></span></p><p class="c4 c3"><span>NOTES FROM HERE ON</span></p><p class="c4 c3"><span>NOTES FROM HERE ON</span></p><p class="c4 c3"><span>NOTES FROM HERE ON</span></p><p class="c4 c3"><span>NOTES FROM HERE ON</span></p><p class="c4 c3"><span>NOTES FROM HERE ON</span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c4"><span>Here we&rsquo;ve used the defaults - subsystem level 3 -- but we can download any data type at any relevant level, for example -- if we wanted to download the level 2 subsystem data we would do the following:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_gut_data.subsystem_lvl2 &lt;- collection (gut_samples, function_counts = view(of = &quot;count&quot;, annotation=&quot;function&quot;, level=&quot;level2&quot;))</span></p><p class="c1"><span></span></p><p class="c4"><span>Note that because this is not a default data call, it will only collect the data requested - the raw count abundances.</span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c4"><span>standardViews &lt;- list (</span></p><p class="c4"><span>&nbsp; &nbsp; count = view (of = &quot;count&quot;),</span></p><p class="c4"><span>&nbsp; &nbsp; normed = view (of = &quot;normed&quot;),</span></p><p class="c4"><span>&nbsp; &nbsp; evalue = view (of = &quot;evalue&quot;),</span></p><p class="c4"><span>&nbsp; &nbsp; length = view (of = &quot;length&quot;),</span></p><p class="c4"><span>&nbsp; &nbsp; percentid = view (of = &quot;percentid&quot;))</span></p><p class="c4"><span>[8/7/12 3:27:50 PM] Kevin Keegan: ... for the selected mgm&#39;s?</span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c4"><span>&lt;-scrubIds(&quot;4440283.3;4440284.3;4440285.3;4440286.3;4440463.3;4440464.3;4441679.3;4441680.3;4441681.3;4441682.3;4440055.3;4440056.3;4440062.3;4440063.3&quot;)</span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c4"><span>c(&quot;Chicken.1&quot;,&quot;Chicken.2&quot;,&quot;Chicken.3&quot;,&quot;Chicken.4&quot;,&quot;LM&quot;,&quot;OM&quot;,&quot;CR1&quot;,&quot;CR2&quot;,&quot;CR3&quot;,&quot;CR4&quot;,&quot;FG1&quot;,&quot;FG2&quot;,&quot;FG3&quot;,&quot;FG4&quot;)</span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c4"><span>CC = Chicken cecum</span></p><p class="c4"><span>LM = Lean mouse</span></p><p class="c4"><span>OM = Obese mouse</span></p><p class="c4"><span>CR = Cow rumen</span></p><p class="c4"><span>FG = Fish gut</span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c4"><span>Download data -- if you need to get data other than subsystem level 3, just let me know and # I or Dan can give you the right syntax -- documentation for the package is a bit spotty at the</span></p><p class="c4"><span>moment</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_data &lt;- collection (my_data_mgids, function_counts = view(of = &quot;count&quot;, annotation=&quot;function&quot;, level=&quot;level3&quot;), normed_function_counts = view(of = &quot;normed&quot;, annotation=&quot;function&quot;, level=&quot;level3&quot;))</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>We have a single data object (my_data) that contains the raw (function_counts) and</span></p><p class="c4"><span>normalized (normed_function_counts) counts for your data</span></p><p class="c1"><span></span></p><p class="c4"><span>Let&#39;s start by look at boxplot of the abundance distributions in the raw and normalized data</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">render (my_data, views = c (&quot;function_counts&quot;, &quot;normed_function_counts&quot;))</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>I&#39;d stick with the normed counts -- distributions look a whole lot better (more similar and normally distributed -- with the exception of the last two)</span></p><p class="c1"><span></span></p><p class="c4"><span>now let&rsquo;s take a peek at how similar the abundance profiles are for the data</span></p><p class="c1"><span></span></p><p class="c4"><span>we&#39;ll produce a PCoA of the normalized values using Euclidean distance</span></p><p class="c4"><span class="c2">my_PCoA &lt;- mpco (my_data$normed_function_counts, method = &quot;euclidean&quot;)</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>create a plot from the first two components</span></p><p class="c4"><span class="c2">render (my_PCoA, main = &quot;This is a test PCoA&quot;, labels = my_data_names)</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>Notice that the last two samples look extremely different from the rest -- these are the two with the wacky distributions -- lets do that again, excluding those two samples:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_data_mgids &lt;-scrubIds(&quot;4440283.3;4440284.3;4440285.3;4440286.3;4440463.3;4440464.3;4441679.3;4441680.3;4441681.3;4441682.3;4440055.3;4440056.3&quot;)</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c2">my_data_names &lt;- c(&quot;CC1&quot;,&quot;CC2&quot;,&quot;CC3&quot;,&quot;CC4&quot;,&quot;LM&quot;,&quot;OM&quot;,&quot;CR1&quot;,&quot;CR2&quot;,&quot;CR3&quot;,&quot;CR4&quot;,&quot;FG1&quot;,&quot;FG2&quot;)</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c2">my_data &lt;- collection (my_data_mgids, function_counts = view(of = &quot;count&quot;, annotation=&quot;function&quot;, level=&quot;level3&quot;), normed_function_counts = view(of = &quot;normed&quot;, annotation=&quot;function&quot;, level=&quot;level3&quot;))</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c2">my_PCoA &lt;- mpco (my_data$normed_function_counts, method = &quot;euclidean&quot;)</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c2">render (my_PCoA, main = &quot;This is a test PCoA&quot;, labels = my_data_names)</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>We see some grouping that makes sense -- lets color the points to make this a little clearer.</span></p><p class="c4"><span>We&rsquo;ll create a vector that has the sample colors, and can also be used to group the samples for the statistical tests below.</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_groupings &lt;- c ( rep(&quot;red&quot;, 4), rep(&quot;blue&quot;, 2), rep(&quot;green&quot;, 4), rep(&quot;hotpink&quot;,2))</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c2">render (my_PCoA, main = &quot;This is a colored test PCoA&quot;, labels = my_data_names, &nbsp;col = my_groupings)</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>CC = Chicken cecum (red)</span></p><p class="c4"><span>LM = Lean mouse (blue)</span></p><p class="c4"><span>OM = Obese mouse (blue)</span></p><p class="c4"><span>CR = Cow rumen (green)</span></p><p class="c4"><span>FG = Fish gut (hotpink)</span></p><p class="c1"><span></span></p><p class="c4"><span>Another way to visualize the data is with a heatmap dendrogram</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">mheatmap (my_data$normed_function_counts, image_out = &quot;my_data_HD.jpg&quot;, labRow = NA, labCol = my_data_names, col_lab_mult = 1.2, margins = c (9,1), image_title = &quot;my_data_heatmap_dendrogram&quot;)</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>now lets see which subsystems exhibit the most significant differences among these four groups - we&#39;ll use ANOVA on the normalized data (parametric tests are justified by the normality we observed in the (normalized data) boxplots)</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_stats &lt;- doStats(my_data$normed_function_counts, my_groupings, &quot;ANOVA-one-way&quot;)</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>write p value analyses to a tab delimited text you can open in excel</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">write.table(my_stats, file = &quot;my_ANOVA_P_values.txt&quot;, col.names=NA, row.names =TRUE, sep=&quot;\t&quot;, quote=FALSE)</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>or get a little fancier and produce a table that has the normalized abundance values followed by the ANOVA analyses</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_output_data &lt;- cbind(as.matrix(my_data$normed_function_counts),my_stats)</span></p><p class="c4"><span class="c2">write.table(my_output_data, file = &quot;my_normed_abundances_and_ANOVA_P_values.txt&quot;, col.names=NA, row.names = TRUE, sep=&quot;\t&quot;, quote=FALSE)</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>It looks as though the fish gut samples are very different from the rest, we can perform another analysis where we compare the data as two groups:</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_groupings &lt;- c ( rep(&quot;red&quot;, 10), rep(&quot;hotpink&quot;,2))</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c2">my_stats &lt;- doStats(my_data$normed_function_counts, my_groupings, &quot;ANOVA-one-way&quot;)</span></p><p class="c4"><span>ANOVA will be the same as a t-test (just two samples)</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">my_output_data &lt;- cbind(as.matrix(my_data$normed_function_counts),my_stats)</span></p><p class="c4"><span class="c2">write.table(my_output_data, file = &quot;my_normed_abundances_and_ANOVA_P_values.txt&quot;, col.names=NA, row.names = TRUE, sep=&quot;\t&quot;, quote=FALSE)</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>CC = Chicken cecum (red)</span></p><p class="c4"><span>LM = Lean mouse (red)</span></p><p class="c4"><span>OM = Obese mouse (red)</span></p><p class="c4"><span>CR = Cow rumen (red)</span></p><p class="c4"><span>FG = Fish gut (hotpink)</span></p><p class="c4"><span>In addition to this demo, the package comes with another demo pre-installed -- it repeats some of the functionality we&rsquo;ve covered here as well as additional features - retrieval of metadata, subselecting data sets based on statistical analysis outputs etc. Note that the entire demo will take a few minutes to run through --</span></p><p class="c1"><span></span></p><p class="c4"><span class="c2">demo2()</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span>Press enter to proceed through each step in this demo</span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c4"><span>##### Notes from here on - please ignore</span></p><p class="c1"><span></span></p><p class="c4"><span>dutilh@cmbi.ru.nl, itai.sharon@gmail.com, k6logc@gmail.com, nathaniel.hubert@gmail.com, wltrimbl@gmail.com, mesude@gmail.com, tgaw@msu.edu, wtang222@gmail.com, anadimpalli1@gmail.com, weigandenator@gmail.com, adina.chuang@gmail.com, googled@d-dub.org.uk, kmhandley@googlemail.com, folker.meyer@gmail.com, dantonop@gmail.com, xzhu1@uchicago.edu,</span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c4"><span>##### Notes - ignore</span></p><p class="c1"><span></span></p><p class="c4"><span>&gt; pvals &lt;- results [ , 4]</span></p><p class="c4"><span>&gt; subW &lt;- W$normed [names (pvals) [pvals &lt; 0.05], ]</span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c1"><span></span></p><p class="c1"><span></span></p></body></html>